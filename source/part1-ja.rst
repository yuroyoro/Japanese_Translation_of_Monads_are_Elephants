「モナドは象だ」 Part1
========================================================================

モナドの紹介はインターネット上のちょっとした家内工業みたいなものです。
なので私は「なぜ慣習を破るのか？」と思うのです。
しかし、この記事ではScalaでモナドを扱う方法を示します。

| 昔の寓話で、こんな話があります。
| 盲目の男たちがいました。彼らは象を知ったばかりでした。

| 1人は「あれば大木だ」と両足を腕で包みながら言いました。
| もう1人は「あれば大蛇だ」と胸を包みながら言いました。
| 3人目の男は「うーん」と言いながら、ほうきか扇か何かを想像しました。

この寓話の結論はこうです。古人は次のように信じていました。 視覚障害者は、大型の哺乳動物をあやすのが好きであると。

幸運にも我々はより賢明な時代に生きています。
自分たちの制約がどれほど全体像をつかみにくくしているか、そして我々もある意味みな盲目であることを学ぶべきです。 まるで禅のようですね。

これは学ぶべき3度目のレッスンだと思います。主な意図とは正反対だけれども。 限られた一連の説明から全体像をより学べるかもしれません。

もし象を一度も見たことがなくても、色々な人から「大木の幹のような足を持っている」「蛇のような鼻だ」「鼻のような尻尾だ」「扇のような耳だ」などと教えてもらえたら、すぐにとてもよい理解が得られるでしょう。
概念は完璧ではないでしょうが、ようやく象を見たときには、ゆっくり築いていた想像の姿ときちんと一致させられるでしょう。
象が歩いてきたら「おお。本当に木のような足だ」と思うでしょう。

「モナドはコンテナのタイプだ」
------------------------------------------------------------------------

リストはもっともよく使われるコンテナのタイプの1つです。なのでリストに少し時間を割きます。

リストとOptionがどう関連するのかはっきりしないかもしれませんが、Optionが要素が0か1の限定されたリストであると考えてみるとヒントになるかもしれません。

ツリーとセットもモナドです。しかし、モナドは象であることを思い出してください。
いくつかのモナドでは、コンテナとして見るには少し見方を変えなければならないかも知れません。

モナドは型パラメータを取ります。リストは有益なコンセプトですが、リストの要素がなにかを知る必要があります。
文字列のリスト(List[String])は数字のリスト(List[Int])は違います。

あるものから他のものに変換することは明らかに有益です。このことが次のポイントにつながります。

「モナドは高階関数をサポートする」
------------------------------------------------------------------------

高階関数とは関数自体を引数にとるか、戻り値として返す関数です。
モナドはいくつかの決まった高階関数を持つコンテナです。今はScalaでの話ですので、モナドはいくつかの高階メソッドを持つと言えます。

mapはそのようなメソッドの1つです。もし関数型言語を知っているなら、どのような形にせよmapに親しんでいるでしょう。
mapメソッドは関数を引数に取り、コンテナの各要素にその関数を適用した結果を新しいコンテナとしてを返します。

たとえば

.. code-block:: scala

  def double(x: Int) = 2 * x
  val xs = List(1, 2, 3)
  val doubles = xs map double
  // val doubles = xs map {2 * _} と書いても良い
  assert(doubles == List(2, 4, 6))


mapはモナドの種類は変えませんが、そのパラメータ化された型を変えられます。

.. code-block:: scala

  val one = Some(1)
  val oneString = one map {_.toString}
  assert(oneString == Some("1"))

ここで{_.toString}は要素のtoStringメソッドを呼び出すという意味の表記です。

「モナドは結合可能だ」
------------------------------------------------------------------------

(ファイルなどの)設定からパラメータを読み出す設定ライブラリを書いているとしましょう。
パラメータはOption[String]型で取得できます。言い換えると、設定値を文字列で取得できるかどうかはパラメータが定義されているかどうかに依存します。

関数stringToIntもあります。Stringを引数に取りSome[Int]を返す関数です。 もし数値に変換できるなら文字列を、そうでないならNoneを返します。

これをmapと組み合わせてみると、とたんに混乱に陥ります。

.. code-block:: scala

  val opString : Option[String] = config fetchParam "MaxThreads"
  def stringToInt(string:String) : Option[Int] = ...
  val result = opString map stringToInt


不幸なことに、Optionの要素に対して、StringをOption[String]に変換する関数でマップするので、変数「result」はOptionを含んだOptionです。すなわちOption[Option[Int]]型です。
これはほとんどの場合ひどく使いにくいものです。

決方法に興味を起こすために、想像してみましょう。もしOptionの代わりにリストを使ってList[List[Int]]]型になったとしたら。

言い換えると、いくつかのリストを含んだリストならどうでしょう。

そうすると「flatten」が必要です。これはリストのリスト(List[List[A]])を引数に取り、すべてを一緒につなぎ合わせて単なるリスト(List[A])にして返します [#flatten]_ 。

Option[Option[A]]のflatten関数は少し異なります。

.. code-block:: scala

  def flatten[A](outer:Option[Option[A]]) : Option[A] =
     outer match {
       case None => None
       case Some(inner) => inner
     }

もnifestし外側(outer)のOptionがNoneなら結果もNoneです。そうでなければ結果はouterのOptionに入っている値(inner) - Some[A]です。

これら2つのflatten関数はシグネチャが似ています。M[M[A]]を引数に取りM[A]に変換します。
しかしその方法はまったく異なります。

他のモナドはそれぞれに適した独自の方法でflattenを実現します。

これを洗練したものとして、「flatten」の代わりに「join」を使ってよくモナドを説明しています。
「join」は外部のモナドにおけるある面が内部のモナドのある面とともに組み合わされ(結合され)ているということをきちんと示しています。

しかしながら私は「flatten」でやります。コンテナのアナロジーにフィットするからです。

さて、Scalaでは明示的にflattenを記述する必要はありません。 しかしflatMapと呼ばれるメソッドを各モナドが持つようにする必要があります。 [#flatmap]_

flatMapとは何でしょう？読んで字のごとく、mapしてその結果をflattenします。

.. code-block:: scala

  class M[A] {
    private def flatten[B](x:M[M[B]]) : M[B] = ...
    def map[B](f: A => B) : M[B] = ...
    def flatMap[B](f: A => M[B]) : M[B] = flatten(map(f))
  }

このことを念頭に置いて、先ほどの問題あるコードを見てみましょう。

.. code-block:: scala

  val opString : Option[String] = config fetchParam "MaxThreads"
  def stringToInt(string:String) : Option[Int] = ...
  val result = opString flatMap stringToInt


flatMapのおかげで、変数resultはOption[Int]型となります。必要であれば、さらにresultを引数にしてIntをOption[Foo]にする関数でflatMapさせることもできます。 それから更に、Foo型をOption[Bar]にする関数でflatMapさせることもできます。などなど。

| 気をつけることとして、モナドに関する多くの論文が「flatMap」の代わりに「bind」という単語を使っています。
| Haskellでは「>>=」という記号を使っています。すべて同じコンセプトです。

「モナドは構築する方法がいくつもある」
------------------------------------------------------------------------

mapを使ってflatMapメソッドを構築する方法を見てきました。 逆も可能です。flatMapをベースにmapを作成することもできます。

| そのためにはもう1つ概念が必要です。モナドに関するほとんどの論文で、その概念は「unit」と呼んでいます。Haskellでは「return」と呼びます。
| Scalaはオブジェクト指向言語なので、同じ概念は単一引数の「コンストラクタ」または「ファクトリ」と呼ぶかもしれません。

基本的に、unitはA型の値を1つ引数に取って、M[A]型のモナドに変換します。リストであればunit(x) == List(x)となり、Optionであればunit(x) == Some(x)となります。

Scalaでは個別の「unit」関数またはメソッドを必要としません。書いても書かなくても構いません。
ここでは、mapを記述するにあたって、単にunitが有効であるかを示すためだけに、明確に「unit」を書くことにします。

.. code-block:: scala

  class M[A](value: A) {
    private def unit[B] (value : B) = new M(value)
    def map[B](f: A => B) : M[B] = flatMap {x => unit(f(x))}
    def flatMap[B](f: A => M[B]) : M[B] = ...
  }


このバージョンのflatMapはmapやflattenへの参照なしに構築する必要があります。mapやflattenを、flatMapの中で一度に行うように実装しなければなりません。

mapは少しおもしろいです。(f)に渡された関数を引数に取り、flatMapに適した"新しい関数"を適用します。その"新しい関数"は{x => unit(f(x))}です。この関数は、まずxに関数fを適用して、その結果にunitを適用する、という意味です。

Part1の結論
------------------------------------------------------------------------

ScalaのモナドはmapとflatMapメソッドを持たなければなりません。mapはflatMapメソッドとコンストラクタを使って実装できますが、逆にflatMapがmapとflattenを使って実装していてもよいです。

| flatMapは象という動物の中心です。モナドに初めて触れるなら、少なくともmapとflattenを使って最初のバージョンのflatMapを構築するといいかもしれません。
| mapは一般的にとても単純です。flattenのために意味を成しているところが難しい部分であると理解してください。

モナドはコレクションではないとわかったとき、flatMapを最初に実装して、mapがflatMapとunitをベースに実装すべきだということが理解できるでしょう。

パート2ではモナドのためScalaのシンタックスシュガーを紹介します。パート3では象のDNAすなわちモナド則を紹介します。 最後となるパート4ではどうにかコンテナであるようなモナドを示します。

話は変わって、モナドについてのコンピュータ科学論文とHaslkell、Scalaを変換するチートシートをお見せします。

+----------------+-------------------------------+-------------------------------------+
| Generic        | Haskell                       | Scala                               |
+================+===============================+=====================================+
| M              | data M a or                   | class M[A] or                       |
|                | newtype M a or                | case class M[A] or                  |
|                | instance Monad (M a)          | trait M[A]                          |
+----------------+-------------------------------+-------------------------------------+
| M a            | M a                           | M[A]                                |
+----------------+-------------------------------+-------------------------------------+
| unit v         | return v                      | new M(v) or                         |
|                |                               | M(v)                                |
+----------------+-------------------------------+-------------------------------------+
| map f m        | fmap f m                      | m map f                             |
+----------------+-------------------------------+-------------------------------------+
| bind f m       | m >>= f or                    | m flatMap f                         |
|                | f =<< m                       |                                     |
+----------------+-------------------------------+-------------------------------------+
| join           | join                          | flatten                             |
+----------------+-------------------------------+-------------------------------------+
|                | do                            | for                                 |
+----------------+-------------------------------+-------------------------------------+



.. rubric:: 脚注

.. [#flatten] Scalaの標準ライブラリのListにはflattenメソッドが含まれています。れはとても巧妙に実装されていますが、説明のためにはimplicit conversions(暗黙の型変換)という重要な仕組みについて説明しなければなりません。その巧妙な部分とは、flattenメソッドはList[List[A]]型に対してのみ意味を成していて、List[A]型では利用できない、ということです。falttenメソッドは全てのListで定義されていますが、含まれる型パラメータに対して静的な型チェックが行われます。

.. [#flatmap] ここでは少し省略しましたが、Scalaではモナドを定義する際に、メソッド名に特別な名前を要求しません。"germufaBitz"とか"frizzle"とかでもよいのです。しかしながら、Scalaのfor内包表記(for式)で利用できる用にしたいならば、mapとflatMapという名前にしておかなければなりません。

